% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tcor.R
\name{tcor}
\alias{tcor}
\alias{pred_tcor}
\title{Compute time varying correlation coefficients}
\usage{
tcor(
  x,
  y,
  t = seq_along(x),
  h = NULL,
  cor.method = c("pearson", "spearman"),
  kernel = c("epanechnikov", "box", "normal"),
  param_smoother = list(),
  keep.missing = FALSE,
  verbose = FALSE
)

pred_tcor(
  x,
  y,
  t = seq_along(x),
  t.for.pred = t,
  h,
  cor.method = c("pearson", "spearman"),
  kernel = c("epanechnikov", "box", "normal"),
  param_smoother = list()
)
}
\arguments{
\item{x}{a numeric vector.}

\item{y}{a numeric vector of to be correlated with \code{x}.}

\item{t}{a (numeric or Date) vector of time points. If missing, observations
are considered to correspond to sequential time steps (i.e. 1, 2 ...).}

\item{h}{a scalar indicating the bandwidth used by the smoothing function.}

\item{cor.method}{a character string indicating which correlation coefficient
is to be computed ("pearson", the default; or "spearman").}

\item{kernel}{a character string indicating which kernel to use: "epanechnikov"
(the default), "box", or "normal" (abbreviations also work).}

\item{param_smoother}{a list of additional parameters to provide to the
internal smoothing function (see \strong{Details}).}

\item{keep.missing}{a logical specifying if time steps associated with missing
information should be kept in the output (default = \code{FALSE} to facilitate plotting).}

\item{verbose}{a logical specifying if information should be displayed to
monitor the progress of the cross validation (default = \code{FALSE}).}

\item{t.for.pred}{a (numeric or Date) vector of time points at which to
evaluate the smoothed fit. If missing, \code{t} is used.}
}
\value{
A dataframe of time points (\code{t}) and corresponding correlation values (\code{r}).
Some metadata are also attached to the dataframe (as attributes):
\itemize{
\item \code{h} the bandwidth parameter.
\item \code{CV_error} the minimal Cross Validation error when \code{h} selected by CV.
\item \code{h_selection} the method used to select \code{h}.
\item \code{h_select_duration} the computing time spent to select the bandwidth
parameter.
}

a dataframe will the time, the correlation value and its underlying (smoothed) components.
}
\description{
The function \code{tcor} implements the nonparametric estimation of the time
varying correlation coefficient proposed by Choi & Shin, 2021. The general
idea is to compute a (Pearson) correlation coefficient (\code{r(x,y) = (mean(xy) - mean(x)*mean(y)) / (sqrt(mean(x^2)-mean(x)^2) * sqrt(mean(y^2)-mean(y)^2))}),
but instead of using the means required for such a computation, each
component (i.e. \code{x}, \code{y}, \code{x^2}, \code{y^2}, \code{x*y}) is smoothed and the smoothed
terms are considered in place the original means. The intensity of the
smoothing depends on a unique parameter: the bandwidth (\code{h}). If \code{h = Inf},
the method produces the original (i.e. time-invariant) correlation value. The
smaller the parameter \code{h}, the more variation in time is being captured. The
parameter \code{h} can be provided by the user; otherwise it is automatically
estimated (see \strong{Details}).
}
\details{
\itemize{
\item \strong{Smoothing}: the smoothing of each component is performed by kernel
regression. The default is to use the Epanechnikov kernel following Choi &
Shin 2021, but other kernels have also been implemented and can thus
alternatively be used (see \code{\link{kern_smooth}} for details). The normal kernell
seems to sometimes lead to very small bandwidth being selected, but the
default can lead to numerical issues. We thus recommend always comparing the
results from different kernel methods.
\item \strong{Bandwidth selection}: when the value used to define the bandwidth (\code{h})
is set to \code{NULL} (the default), it is first estimated by leave-one-out cross
validation. If cross validation error is minimal for the maximal value of \code{h}
considered (\code{8*sqrt(N)}), rather than taking this as the optimal \code{h} value,
the bandwidth becomes estimated using the so-called elbow criterion. This
latter method identifies the value \code{h} after which the cross validation error
decreasing very little. The procedure is detailed in section 2.1 in Choi &
Shin, 2021.
\item \strong{Parallel computation}: if \code{h} is not provided, an automatic bandwidth
selection occurs (see above). For large datasets, this step can be
computationally demanding. The current implementation thus relies on
\code{\link[parallel:mclapply]{parallel::mclapply}} on thus is only effective for Linux and MacOS. Relying
on parallel processing also implies that you call \code{options("mc.cores" = XX)}
beforehand, replacing \code{XX} by the relevant number of CPU cores you want to use
(see \strong{Examples}).
}
}
\section{Functions}{
\itemize{
\item \code{pred_tcor}: Internal function computing the correlation for a given bandwidth
}}

\examples{

## Effect of the bandwidth

res_h50  <- with(stockprice, tcor(x = SP500, y = FTSE100, t = DateID, h = 50))
res_h100  <- with(stockprice, tcor(x = SP500, y = FTSE100, t = DateID, h = 100))
res_h200 <- with(stockprice, tcor(x = SP500, y = FTSE100, t = DateID, h = 200))
plot(res_h50, type = "l", ylab = "Cor", xlab = "Time", las = 1, col = "grey")
points(res_h100, type = "l", col = "blue")
points(res_h200, type = "l", col = "red")
legend("topright", fill = c("grey", "blue", "red"),
       legend = c("50", "100", "200"), bty = "n", title = "Bandwidth (h)")


## Effect of the correlation method

res_pearson <- with(stockprice, tcor(x = SP500, y = FTSE100, t = DateID, h = 150))
res_spearman <- with(stockprice, tcor(x = SP500, y = FTSE100, t = DateID, h = 150,
                                     cor.method = "spearman"))
plot(res_pearson, type = "l", ylab = "Cor", xlab = "Time", las = 1)
points(res_spearman, type = "l", col = "blue")
legend("topright", fill = c("black", "blue"),
       legend = c("pearson", "spearman"), bty = "n", title = "cor.method")


## Infinite bandwidth and fixed correlation correspondance
## nb: does not work with default kernel

res_pearson_hInf  <- with(stockprice, tcor(x = SP500, y = FTSE100, t = DateID, h = Inf,
                                           kernel = "normal"))
res_spearman_hInf <- with(stockprice, tcor(x = SP500, y = FTSE100, t = DateID, h = Inf,
                                           kernel = "normal", cor.method = "spearman"))
r <- cor(stockprice$SP500, stockprice$FTSE100, use = "pairwise.complete.obs")
rho <- cor(stockprice$SP500, stockprice$FTSE100, method = "spearman", use = "pairwise.complete.obs")
plot(res_pearson_hInf, type = "l", ylim = c(0, 1), ylab = "Cor", xlab = "Time", las = 1, lwd = 4)
points(res_spearman_hInf, type = "l", lwd = 4, col = "blue")
abline(h = r, col = "red", lty = 2, lwd = 2)
abline(h = rho, col = "green", lty = 2, lwd = 2)


\dontrun{
## Automatic selection of the bandwidth using parallel processing and comparison
## of the 3 alternative kernels on full dataset
# nb: takes a few minutes to run

options("mc.cores" = 2L)
res_hauto_epanech <- with(stockprice, tcor(x = SP500, y = FTSE100, t = DateID,
                                          verbose = TRUE))
res_hauto_box <- with(stockprice, tcor(x = SP500, y = FTSE100, t = DateID,
                                       kernel = "box", verbose = TRUE))
res_hauto_norm <- with(stockprice, tcor(x = SP500, y = FTSE100, t = DateID,
                                        kernel = "norm", verbose = TRUE))
plot(res_hauto_epanech, type = "l", col = "red",
     ylab = "Cor", xlab = "Time", las = 1, ylim = c(0, 1))
points(res_hauto_box, type = "l", col = "blue")
points(res_hauto_norm, type = "l", col = "orange")
legend("topright", fill = c("red", "blue", "orange"),
       legend = c("epanechnikov", "box", "normal"), bty = "n",
       title = "Kernel")


## Cross validation error according to each kernel

attr(res_hauto_epanech, "CV_error")
attr(res_hauto_box, "CV_error")
attr(res_hauto_norm, "CV_error")

## Selected bandwidth according to each kernel

attr(res_hauto_epanech, "h")
attr(res_hauto_box, "h")
attr(res_hauto_norm, "h")


## Comparison of the 3 alternative kernels under same bandwidth

res_epanech <- with(stockprice, tcor(x = SP500, y = FTSE100, t = DateID,
                                     h = attr(res_hauto_epanech, "h")))
res_box <- with(stockprice, tcor(x = SP500, y = FTSE100, t = DateID, kernel = "box",
                                 h = attr(res_hauto_epanech, "h")))
res_norm <- with(stockprice, tcor(x = SP500, y = FTSE100, t = DateID, kernel = "norm",
                                  h = attr(res_hauto_epanech, "h")))

plot(res_epanech, type = "l", col = "red", ylab = "Cor", xlab = "Time",
     las = 1, ylim = c(0, 1))
points(res_box, type = "l", col = "grey")
points(res_norm, type = "l", col = "orange")
legend("topright", fill = c("red", "grey", "orange"),
       legend = c("epanechnikov", "box", "normal"), bty = "n",
       title = "Kernel")


## Not all kernels work well in all situations
## nb: EuStockMarkets is a time-series object provided with R

EuStock_epanech <- tcor(EuStockMarkets[, "DAX"], EuStockMarkets[, "SMI"])
plot(EuStock_epanech, type = "l", las = 1) ## problem of estimation for first and last years

EuStock_norm <- tcor(EuStockMarkets[, "DAX"], EuStockMarkets[, "SMI"], kernel = "normal")
plot(EuStock_norm, type = "l", las = 1) ## normal kernel seems to work great with these data

}



##################################################################
## Examples for the internal function computing the correlation ##
##################################################################

with(head(stockprice), pred_tcor(x = SP500, y = FTSE100, t = DateID, h = 20))
with(head(stockprice), pred_tcor(x = SP500, y = FTSE100, t = DateID, h = 20,
     t.for.pred = DateID[1]))

## The function can handle non consecutive time points

set.seed(1)
pred_tcor(x = rnorm(10), y = rnorm(10), t = c(1:2, 23:30), h = 2)


## The function can handle non-ordered time series

with(head(stockprice)[c(1, 3, 6, 2, 4, 5), ], pred_tcor(x = SP500, y = FTSE100, t = DateID, h = 20))


## Note: the function does not handle missing data (by design)

# pred_tcor(x = c(NA, rnorm(9)), y = rnorm(10), t = c(1:2, 23:30), h = 2) ## should err if ran!

}
\references{
Choi, JE., Shin, D.W. Nonparametric estimation of time varying correlation coefficient.
J. Korean Stat. Soc. 50, 333–353 (2021). https://doi.org/10.1007/s42952-020-00073-6
}
\seealso{
\code{\link{kern_smooth}}
}
